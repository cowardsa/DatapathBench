import os
import glob
import subprocess
import time
import re
import sys
import csv
from tracemalloc import start
import matplotlib.pyplot as plt
import numpy as np
from datetime import datetime
import shutil
from dataclasses import dataclass


################################################################################
# Helper Functions
################################################################################
def run(cmd, stdout=None):
    """Run a shell command and optionally redirect stdout."""
    if stdout:
        with open(stdout, 'w') as f:
            subprocess.run(cmd, shell=True, stdout=f, stderr=subprocess.STDOUT)
    else:
        subprocess.run(cmd, shell=True, check=True)

def can_run_command(command):
    """Check if a command is available on the system."""
    return shutil.which(command) is not None

def grep_stat(filename, pattern, group=1):
    """Extract a number from a file using a regex pattern."""
    with open(filename) as f:
        for line in f:
            m = re.search(pattern, line)
            if m:
                return m.group(group)
    return ""

################################################################################
# Synthesis Data Classes
################################################################################
# @dataclass
class SynthDataSet:
    def __init__(self, name, dir, output_dir, bw=None):
        self.name = name
        self.dir = dir
        self.output_dir = output_dir
        self.bw = bw
        self.stats = {}
        self.sv_file = f"{self.dir}/sv/{self.dir}.sv"
        self.comb_mlir_file = f"{self.output_dir}/{self.dir}..comb.mlir"
        self.mlir_aig_file = f"{self.output_dir}/{self.dir}.{self.name}.aig.mlir"
        self.aiger_file = f"{self.output_dir}/{self.dir}.{self.name}.aig"

    # Convert sv to comb mlir and run circt-synth
    def run_circt_synth(self, options=""):
        # Generate comb MLIR from SV
        run(f'circt-verilog {self.dir}/sv/{self.dir}.sv -G BW={self.bw} -o {self.comb_mlir_file}')

        # Run once with timing to get longest path
        run(f'circt-synth {self.comb_mlir_file} {options} -o {self.mlir_aig_file} --output-longest-path={self.output_dir}/{self.dir}.{self.name}.path')
        self.stats['circt_levels'] = grep_stat(f"{self.output_dir}/{self.dir}.{self.name}.path", r'Maximum path delay: ([0-9]+)')
        
        # Run again to get clean timing info - without longest path analysis
        # Comb --> AIG in MLIR
        start = time.time()
        run(f'circt-synth {self.comb_mlir_file} {options} -o {self.mlir_aig_file}')
        self.stats['circt_time'] = time.time() - start
        
        # AIG in MLIR --> AIGER format
        start1 = time.time()
        run(f'circt-translate {self.output_dir}/{self.dir}.{self.name}.aig.mlir --export-aiger -o {self.aiger_file}')
        self.stats['mlir_to_aiger_time'] = time.time() - start1
        
    # Convert sv to comb mlir and run circt-synth, then verify equivalence of the two mlir circuits
    def verify_circt_synth(self, options=""):
        # Can only verify circuits expressed in comb - so run with --convert-to-comb    
        run(f'circt-synth {self.comb_mlir_file} {options} --convert-to-comb -o {self.mlir_aig_file}')

        # TODO: implement equivalence checking here

    # Run yosys synthesis on either sv or aiger input from circt-synth flow
    def run_yosys_synth(self, input_fmt):
        
        yosys_cmd = f' synth;'
        # Process System Verilog
        if input_fmt == "sv":
            yosys_cmd = f'read_verilog -sv {self.sv_file}; chparam -set BW {self.bw} {self.dir};' + yosys_cmd

            # Export AIGER
            yosys_cmd += f' aigmap; write_aiger {self.aiger_file};'
            
        # Process AIGER (generated by circt-synth)
        elif input_fmt == "aiger":
            yosys_cmd = f'read_aiger {self.aiger_file};' + yosys_cmd
        else:
            print(f"Error: Unsupported input format '{input_fmt}' for yosys synthesis.")
            assert False

        
        stat_file = f"{self.output_dir}/{self.dir}.{self.name}.yosys_stat"
        start = time.time()
        # Run Yosys synthesis and generate an AIGER file if processing sv
        run(f'yosys -f verilog -p "{yosys_cmd}" > {stat_file}')
        self.stats['yosys_time'] = time.time() - start
        self.stats['yosys_cells'] = grep_stat(stat_file, r'Number of cells: +([0-9]+)')
        

    def print_header(self):
        header = ""
        for key in self.stats.keys():
            header += f" {key} "
        return header.rstrip(' | ')
    
    def print_string(self):
        line = ""
        for key in self.stats.keys():
            width = len(key)
            val = self.stats[key]
            try:
                num = float(val)
                if num == int(num):
                    formatted = str(int(num))
                else:
                    formatted = f"{num:.2f}"
            except (ValueError, TypeError):
                formatted = str(val)
            line += f" {formatted:>{width}} "
        return line.rstrip(' | ')

################################################################################
# Main Function
################################################################################
# Usage: python3 eval_bench.py <bitwidth> [directory]
def main():

    # Preprocessing checks
    requirements = ["circt-synth", "circt-opt", "circt-translate", "yosys"]
    for req in requirements:
        if not can_run_command(req):
            print(f"Error: Required command '{req}' is not available. Please install it and ensure it's in your PATH.")
            sys.exit(1)

    if len(sys.argv) < 2:
        print("Error: No bitwidth specified")
        print("Usage: python eval_bench.py <integer> [directory]")
        sys.exit(1)

    bw = sys.argv[1]
    if not bw.isdigit():
        print("Error: Bitwidth must be a positive integer")
        print("Usage: python eval_bench.py <integer> [directory]")
        sys.exit(1)

    if len(sys.argv) >= 3:
        dirs = [sys.argv[2]]
    else:
        dirs = [d for d in glob.glob("*/") if os.path.isdir(d)]
    
    print_header = True
    names = []
    cells_list = {'comb': [], 'datapath': [], 'yosys': []}
    circt_levels_list = {'comb': [], 'datapath': []}

    # Create output directory
    output_dir = f"output"
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    # Iterate through all benchmark directories        
    for dir in dirs:
        dir = dir.rstrip('/')

        if dir == "output":
            continue
        
        names.append(dir)

        # Baseline Yosys - pass bitwidth parameter
        yosys = SynthDataSet("yosys", dir, output_dir, bw)
        yosys.run_yosys_synth("sv")
        # Add stats for plotting
        cells_list['yosys'].append(int(yosys.stats['yosys_cells']))
        
        # Baseline circt-synth - disable datapath optimizations
        comb = SynthDataSet("comb", dir, output_dir, bw)
        comb.run_circt_synth("--disable-datapath")
        comb.run_yosys_synth("aiger")
        # Add stats for plotting
        cells_list['comb'].append(int(comb.stats['yosys_cells']))
        circt_levels_list['comb'].append(int(comb.stats['circt_levels']))

        # Full circt-synth - enable datapath optimizations
        datapath = SynthDataSet("datapath", dir, output_dir, bw)
        datapath.run_circt_synth()
        datapath.run_yosys_synth("aiger")
        # Add stats for plotting
        cells_list['datapath'].append(int(datapath.stats['yosys_cells']))
        circt_levels_list['datapath'].append(int(datapath.stats['circt_levels']))

        if print_header:
            print_header = False
            top_row = f"{'':<20} | {comb.name.upper():^{len(comb.print_header())}} "
            top_row += f"| {datapath.name.upper():^{len(datapath.print_header())}} "
            top_row += f"| {yosys.name.upper():^{len(yosys.print_header())}}"
            print(top_row)
            print(f"{'':<20} | {comb.print_header()} | {datapath.print_header()} | {yosys.print_header()}")
            print(f"{'-'*20}-+-{'-'*len(comb.print_header())}-+-{'-'*len(datapath.print_header())}-+-{'-'*len(yosys.print_header())}")

        print(f"{dir:<20} | {comb.print_string()} | {datapath.print_string()} | {yosys.print_string()}")

        
    
    ############################################################################
    # Tabulation
    ############################################################################
    if len(sys.argv) < 3:
        # Write results to CSV
        csv_file = f"{output_dir}/results_{bw}bit.csv"
        with open(csv_file, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow([
                "Name",
                "Yosys Cells",
                "Comb Cells", "Comb Levels (CIRCT)",
                "Datapath Cells", "Datapath Levels (CIRCT)"
            ])
            for i in range(len(names)):
                writer.writerow([
                    names[i],
                    cells_list['yosys'][i], 
                    cells_list['comb'][i], circt_levels_list['comb'][i],
                    cells_list['datapath'][i], circt_levels_list['datapath'][i]
                ])
        print(f"\nResults written to {csv_file}")

    
    ############################################################################
    # Plotting
    ############################################################################
    # Normalized ratios
    yosys_comparison_cell_ratios = [d/y if y else 0 for d, y in zip(cells_list['datapath'], cells_list['yosys'])]
    circt_level_ratios = [d/y if y else 0 for d, y in zip(circt_levels_list['datapath'], circt_levels_list['comb'])]
    comb_datapath_level_ratios = [d/y if y else 0 for d, y in zip(circt_levels_list['datapath'], circt_levels_list['comb'])]
    
    x = np.arange(len(names))  # label locations
    width = 0.35  # width of the bars

    # Create a 2x2 grid of subplots
    fig, axs = plt.subplots(2, 2, figsize=(14, 10))
    fig.suptitle(f"{bw}-bit", fontsize=18)
    
    # Datapath vs Yosys Cells Ration - Measured using Yosys
    axs[0, 0].set_title('Datapath/Yosys Cells Ratio (measured by Yosys)')
    bar1 = axs[0, 0].bar(x - width/4, yosys_comparison_cell_ratios, width/2, color='tab:blue', label='Cells')
    axs[0, 0].axhline(y=1, color='red', linestyle='--')
    axs[0, 0].set_xticks(x)
    axs[0, 0].set_xticklabels(names, rotation=45, ha='right')
    axs[0, 0].set_ylabel('Ratio')
    axs[0, 0].set_ylim(0, max(yosys_comparison_cell_ratios + [1.2]))
    # axs[0, 0].legend()

    # Datapath vs Comb Levels Ratios - Measured using CIRCT
    axs[0, 1].set_title('Datapath/Comb Longest Path Ratio (measured by CIRCT)')
    bar4 = axs[0, 1].bar(x + width/4, circt_level_ratios, width/2, color='tab:green', label='CIRCT')
    axs[0, 1].axhline(y=1, color='red', linestyle='--')
    axs[0, 1].set_xticks(x)
    axs[0, 1].set_xticklabels(names, rotation=45, ha='right')
    axs[0, 1].set_ylabel('Levels Ratio')
    axs[0, 1].set_ylim(0, max(comb_datapath_level_ratios + circt_level_ratios + [1.2]))
    # axs[0, 1].legend()

    # Cells comparison comb vs datapath vs yosys
    axs[1, 0].set_title('Cells (measeured by Yosys)')
    axs[1, 0].bar(x - width/2, cells_list['comb'], width/2, color='tab:red', label='Comb')
    axs[1, 0].bar(x, cells_list['datapath'], width/2, color='tab:green', label='Datapath')
    axs[1, 0].bar(x + width/2, cells_list['yosys'], width/2, color='tab:purple', label='Yosys')
    axs[1, 0].set_xticks(x)
    axs[1, 0].set_xticklabels(names, rotation=45, ha='right')
    axs[1, 0].set_ylabel('Cells')
    axs[1, 0].legend()

    # Longest Path comparison comb vs datapath
    axs[1, 1].set_title('Longest Path Comparison (measured by CIRCT)')
    axs[1, 1].bar(x - width/2, circt_levels_list['comb'], width/2, color='tab:red', label='Comb')
    axs[1, 1].bar(x, circt_levels_list['datapath'], width/2, color='tab:green', label='Datapath')
    axs[1, 1].set_xticks(x)
    axs[1, 1].set_xticklabels(names, rotation=45, ha='right')
    axs[1, 1].set_ylabel('Levels')
    
    axs[1, 1].legend()

    plt.tight_layout()
    plt.show()  

if __name__ == "__main__":
    main()